<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [zapps-wg] Zkproofs.org standards workshop
   </TITLE>
   <LINK REL="Index" HREF="/pipermail/zapps-wg/2018/index.html" >
   <LINK REL="made" HREF="mailto:zapps-wg%40lists.zfnd.org?Subject=Re%3A%20%5Bzapps-wg%5D%20Zkproofs.org%20standards%20workshop&In-Reply-To=%3CCAF-ezXYcj5eyWHydacB1znEnr5uskGyAGVg2TReZh_Tyya9vRw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000351.html">
   <LINK REL="Next"  HREF="000369.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[zapps-wg] Zkproofs.org standards workshop</H1>
    <B>Lucas Vogelsang</B> 
    <A HREF="mailto:zapps-wg%40lists.zfnd.org?Subject=Re%3A%20%5Bzapps-wg%5D%20Zkproofs.org%20standards%20workshop&In-Reply-To=%3CCAF-ezXYcj5eyWHydacB1znEnr5uskGyAGVg2TReZh_Tyya9vRw%40mail.gmail.com%3E"
       TITLE="[zapps-wg] Zkproofs.org standards workshop">l at lucasvo.com
       </A><BR>
    <I>Sun Apr 22 11:21:11 EDT 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000351.html">[zapps-wg] Zkproofs.org standards workshop
</A></li>
        <LI>Next message (by thread): <A HREF="000369.html">[zapps-wg] Zkproofs.org standards workshop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#368">[ date ]</a>
              <a href="thread.html#368">[ thread ]</a>
              <a href="subject.html#368">[ subject ]</a>
              <a href="author.html#368">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Andrew, I wanted to follow up on your proposal of formulating ZkPoKs. One
thing that was a bit counter intuitive to your notation is the fact that
while it's very clear what private inputs a snark has, the public inputs
are not clearly designated. E.g.:

ZkPoK{ (R1, R2): H1 = sha256(R1) and H2 = sha256(R2) and R1 = R2 ^ X }

This example is simple enough that a) X is easy to spot and given it's name
it's easy to deduct that this is probably not a constant but a public
input. However if the snark gets longer, intermediary variables (just local
to the snark) and public inputs are hard to discern. Perhaps it would be
convenient to write it with the following syntax:

ZkPoK{ W = {R1, R2}, I = {X}: H1 = sha256(R1) and H2 = sha256(R2) and R1 =
R2 ^ X }

Have you put any thought into this already? Comparing your notation to
Izaak's pseudocode, I think there is a right time and place for both.
Although perhaps by the time you're using your proposed syntax, Izaak, it
might be easier to just write it in snarky, don't you agree?

Lucas

On Mon, Mar 26, 2018 at 6:10 PM, Izaak Meckler via zapps-wg &lt;
<A HREF="/mailman/listinfo/zapps-wg">zapps-wg at lists.z.cash.foundation</A>&gt; wrote:

&gt;<i> One application that I like: sending ads with a proof proving they were
</I>&gt;<i> generated by some algorithm that is known not to have access to personal
</I>&gt;<i> data.
</I>&gt;<i>
</I>&gt;<i> And I like that notation Andrew -- there is a sort of extension to it
</I>&gt;<i> (which is basically the idea of snarky) which involves not having to
</I>&gt;<i> declare all your witnesses up front. The main advantage over
</I>&gt;<i> the Camenisch-Stadler notation to my mind is modularity/abstraction. (For
</I>&gt;<i> example, you can factor out the idea of opening a commitment).
</I>&gt;<i>
</I>&gt;<i> This is a bit of a contrived example but to get the idea across,
</I>&gt;<i> &quot;sumCommitmentsIsZero&quot; proves that you know openings to a bunch of
</I>&gt;<i> commitments such that the openings sum to 0, say.
</I>&gt;<i>
</I>&gt;<i> def openCommitment(c):
</I>&gt;<i>   (value, nonce) = *exists* OpenCommitment(c);
</I>&gt;<i>   *assert* SHA256(value, nonce) = c;
</I>&gt;<i>   return value
</I>&gt;<i>
</I>&gt;<i> def sumCommitmentsIsZero(cs):
</I>&gt;<i>   *assert* sum(map cs (fun c -&gt; openCommitment(c))) = 0
</I>&gt;<i>
</I>&gt;<i> (sometimes I call exists &quot;request&quot; instead.)
</I>&gt;<i>
</I>&gt;<i> If this sort of notation was widely used, people would probably know what
</I>&gt;<i> you meant when you wrote openCommitment as a function, and so you could
</I>&gt;<i> just write the second definition in communicating. There are a bunch of
</I>&gt;<i> other reusable abstractions that arise in zk-proof programming that we
</I>&gt;<i> could build up a shared vocabulary for as well to make communicating this
</I>&gt;<i> stuff easier.
</I>&gt;<i>
</I>&gt;<i> On Sat, Mar 24, 2018 at 4:05 PM, Andrew Miller via zapps-wg &lt;
</I>&gt;<i> <A HREF="/mailman/listinfo/zapps-wg">zapps-wg at lists.z.cash.foundation</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Lucas's post reminded me of something I wanted to post about:
</I>&gt;&gt;<i> If there's one thing I'd like to take up the torch for and advocate as a
</I>&gt;&gt;<i> standard, it's to use a conventional pseudocode for describing snark
</I>&gt;&gt;<i> application ideas. What I have in mind is Camenisch-Stadler proof
</I>&gt;&gt;<i> notation. It looks like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  ZkPoK{ (witness):  Predicate(statement, witness) }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The idea is that &quot;witness&quot; is the private witness, &quot;statement&quot; is
</I>&gt;&gt;<i> public information that the verifier provides, and you replace
</I>&gt;&gt;<i> &quot;Predicate&quot; with whatever pseudocode you want to check.
</I>&gt;&gt;<i> Here are some examples:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. Pay-to-Sudoku:
</I>&gt;&gt;<i>  ZkPoK{ (solution, nonce):
</I>&gt;&gt;<i>      SHA2(nonce || solution) == H,
</I>&gt;&gt;<i>      CheckSudokuSolution(puzzleBoard, solution) == 1 }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 2. Show two hashes have related preimages:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ZkPoK{ (R1, R2): H1 = sha256(R1) and H2 = sha256(R2) and R1 = R2 ^ X }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   <A HREF="https://github.com/ebfull/lightning_circuit/blob/master/README.md">https://github.com/ebfull/lightning_circuit/blob/master/README.md</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This notation is a starting point, it can be extended to say a
</I>&gt;&gt;<i> Signature-of-Knowledge, like in BabyZoe (a simplified form of ZSL,
</I>&gt;&gt;<i> where the only shielded operation is to withdraw 1.0 coin from the
</I>&gt;&gt;<i> shielded pool):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 3. SoK[tx]{ (secretkey, Com, merkleProof):
</I>&gt;&gt;<i>    // Com is included in the commitment tree
</I>&gt;&gt;<i>    MerkleVerify(coinTree, merkleProof, Com),
</I>&gt;&gt;<i>    Com is a commitment to (secretkey, Nullifier)
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Notes on BabyZoe:
</I>&gt;&gt;<i> <A HREF="https://github.com/zcash-hackworks/babyzoe/blob/master/talks">https://github.com/zcash-hackworks/babyzoe/blob/master/talks</A>
</I>&gt;&gt;<i> /2016-07-27-IC3---SNARKs-for-Ethereum.pdf
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> To take a stab at translating the snark-based password authentication
</I>&gt;&gt;<i> idea into this pseudocode, I think it could look like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 4. SoK[signedMessage]{ (derivedkey):
</I>&gt;&gt;<i>     username = SHA256(addrContract, derivedkey)
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The user would then use standard PBKDF2  from something like:
</I>&gt;&gt;<i>    derivedKey := Argon2(addrContract, password)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> so the snark circuit itself doesn't even have to have the expensive
</I>&gt;&gt;<i> hash. The smart contract would use the final password hash as the
</I>&gt;&gt;<i> username.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Sat, Mar 24, 2018 at 4:47 PM, Andrew Miller &lt;<A HREF="/mailman/listinfo/zapps-wg">soc1024 at illinois.edu</A>&gt;
</I>&gt;&gt;<i> wrote:
</I>&gt;&gt;<i> &gt; That's awesome Lucas, thanks for this input, these are pretty cool
</I>&gt;&gt;<i> &gt; application scenarios. They're all quite relevant to a standards effort
</I>&gt;&gt;<i> &gt; because they seem to involve interfacing between zkSNARKs and other
</I>&gt;&gt;<i> &gt; standardized primitives (password hash functions, anonymous credentials,
</I>&gt;&gt;<i> &gt; extensions to ZSL).
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; On Sat, Mar 24, 2018 at 4:42 PM, Lucas Vogelsang via zapps-wg
</I>&gt;&gt;<i> &gt; &lt;<A HREF="/mailman/listinfo/zapps-wg">zapps-wg at lists.z.cash.foundation</A>&gt; wrote:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; I've put some thoughts into possible use cases, here are some that we
</I>&gt;&gt;<i> have
</I>&gt;&gt;<i> &gt;&gt; been thinking about in the context of decentralized business
</I>&gt;&gt;<i> applications.
</I>&gt;&gt;<i> &gt;&gt; Some of these concepts are things we are actually working on, others
</I>&gt;&gt;<i> just
</I>&gt;&gt;<i> &gt;&gt; ideas
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; - blind auctions (including double dutch auctions)
</I>&gt;&gt;<i> &gt;&gt; - page-rank style algorithms on top of anonymous credentials or
</I>&gt;&gt;<i> &gt;&gt; reputations
</I>&gt;&gt;<i> &gt;&gt; - build a password-based authentication out of any password hash
</I>&gt;&gt;<i> &gt;&gt; - give out &quot;referral capabilities&quot; that automatically assign a
</I>&gt;&gt;<i> commission
</I>&gt;&gt;<i> &gt;&gt; to whoever introduced a subscriber who signs up (this would be part of
</I>&gt;&gt;<i> a
</I>&gt;&gt;<i> &gt;&gt; privacy-preserving subscription service, that could be built on top of
</I>&gt;&gt;<i> a
</I>&gt;&gt;<i> &gt;&gt; zcash-like (ZSL protocol) cryptocurrency)
</I>&gt;&gt;<i> &gt;&gt; - consumer credit scores: create a registry of &quot;bad debtors&quot;. use
</I>&gt;&gt;<i> zkproofs
</I>&gt;&gt;<i> &gt;&gt; both to &quot;register&quot; a bad debt/bad action and allow individuals to
</I>&gt;&gt;<i> provide a
</I>&gt;&gt;<i> &gt;&gt; proof revealing your score without actual transaction details (not
</I>&gt;&gt;<i> sure how
</I>&gt;&gt;<i> &gt;&gt; exactly this could work)
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Curious to hear what other people have thought of!
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; On Fri, Mar 23, 2018 at 11:11 AM, Andrew Miller via zapps-wg
</I>&gt;&gt;<i> &gt;&gt; &lt;<A HREF="/mailman/listinfo/zapps-wg">zapps-wg at lists.z.cash.foundation</A>&gt; wrote:
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;&gt; Dear Zapps, I just wanted to let you know that there will be a
</I>&gt;&gt;<i> standards
</I>&gt;&gt;<i> &gt;&gt;&gt; workshop organized by several academics / industry participants in
</I>&gt;&gt;<i> May.
</I>&gt;&gt;<i> &gt;&gt;&gt; <A HREF="https://zkproof.org">https://zkproof.org</A>
</I>&gt;&gt;<i> &gt;&gt;&gt;  I want to make sure that the workshop includes input from all the
</I>&gt;&gt;<i> groups
</I>&gt;&gt;<i> &gt;&gt;&gt; involved in this open source community that are developing tools and
</I>&gt;&gt;<i> &gt;&gt;&gt; applications and even making initial standardization efforts around
</I>&gt;&gt;<i> &gt;&gt;&gt; portability between different libraries.
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;&gt;  I'm especially interested in collecting application ideas to include
</I>&gt;&gt;<i> as
</I>&gt;&gt;<i> &gt;&gt;&gt; case studies to help make the conversation more concrete. So far I
</I>&gt;&gt;<i> don't
</I>&gt;&gt;<i> &gt;&gt;&gt; have many ideas. So far I have:
</I>&gt;&gt;<i> &gt;&gt;&gt; - anonymous credentials
</I>&gt;&gt;<i> &gt;&gt;&gt; - zcash
</I>&gt;&gt;<i> &gt;&gt;&gt; - voting
</I>&gt;&gt;<i> &gt;&gt;&gt; - sudoku solutions / contingent payments
</I>&gt;&gt;<i> &gt;&gt;&gt; - compressing blockchain verification
</I>&gt;&gt;<i> &gt;&gt;&gt; - a log of photo edits
</I>&gt;&gt;<i> &gt;&gt;&gt; - checking that a cloud compute task was done correctly (this is
</I>&gt;&gt;<i> arguably
</I>&gt;&gt;<i> &gt;&gt;&gt; not specific enough).
</I>&gt;&gt;<i> &gt;&gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;&gt; Suggestions of what I'm missing?
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; --
</I>&gt;&gt;<i> &gt; Andrew Miller
</I>&gt;&gt;<i> &gt; University of Illinois at Urbana-Champaign
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> --
</I>&gt;&gt;<i> Andrew Miller
</I>&gt;&gt;<i> University of Illinois at Urbana-Champaign
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="/pipermail/zapps-wg/attachments/20180422/1b8b8e74/attachment.html">/pipermail/zapps-wg/attachments/20180422/1b8b8e74/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000351.html">[zapps-wg] Zkproofs.org standards workshop
</A></li>
	<LI>Next message (by thread): <A HREF="000369.html">[zapps-wg] Zkproofs.org standards workshop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#368">[ date ]</a>
              <a href="thread.html#368">[ thread ]</a>
              <a href="subject.html#368">[ subject ]</a>
              <a href="author.html#368">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="/mailman/listinfo/zapps-wg">More information about the zapps-wg
mailing list</a><br>
</body></html>
